//-----------------------------------------------
//
//  Configuration for XGS5000
//
//  WIP Last Changed Rev : 17175
//-----------------------------------------------

/* Headers */
#include "osincludes.h"

#include "XGS_Ctrl.h"

//---------------------------------
// Constants for XGS 5K FOT  
//---------------------------------
// SFOTand EFOT numbers

// SFOT 16 lanes ->
// SFOT 4 lanes  ->
// EFOT 16 lanes ->
// EFOT 4 lanes  ->

//Short Integration time
// SFOT
// EFOT








//-----------------------------------------------
// Init specific 
//-----------------------------------------------
void CXGS_Ctrl::XGS5M_SetGrabParamsInit5000(int lanes)
   {

   SensorParams.SENSOR_TYPE          = 5000;
   SensorParams.XGS_HiSPI_Ch         = 16;
   SensorParams.XGS_HiSPI_Ch_used    = 4;
   SensorParams.XGS_HiSPI_mux        = 4;
   SensorParams.XGS_DMA_LinePtrWidth = 2; //4 line buffers

   SensorParams.Xsize_Full          = 2600;                                                // Interpolation INCLUDED
   SensorParams.Ysize_Full          = 2056;                                                // Interpolation INCLUDED
   
   SensorParams.XGS_X_START         = 88;                                                  // MONO : Location of first valid x pixel(including Interpolation, dummies, bl, valid)
   SensorParams.XGS_X_END           = SensorParams.XGS_X_START+ SensorParams.Xsize_Full-1; // MONO : Location of last valid x pixel(including Interpolation, dummies, bl, valid)
   
   SensorParams.XGS_X_SIZE          = 2784;                                                // FULL X, including everything
   SensorParams.XGS_Y_SIZE          = 2078;                                                // FULL Y, including everything (M_LINES as in the SPEC, may be modified with dcf M_LINES PROGRAMMED)

   // This may depend on the configuration (Lanes+LineSize) 

   SensorParams.FOTn_2_EXP          = 76800;

   SensorParams.ReadOutN_2_TrigN    = 51200; 

   SensorParams.TrigN_2_FOT         = 23000 * GrabParams.XGS_LINE_SIZE_FACTOR;

   SensorParams.EXP_FOT             = 7000;

   SensorParams.EXP_FOT_TIME        = SensorParams.TrigN_2_FOT + SensorParams.EXP_FOT;  //TOTAL : 23us trig fall to FOT START  + 5.36us calculated from start of FOT to end of real exposure in dev board, to validate!

   SensorParams.KEEP_OUT_ZONE_START = 0x2bf;

   GrabParams.FOT                   = 10; // FOT exprime en nombre de ligne senseur, utilise en mode EO_FOT_SEL=1.

   GrabParams.Y_START               = 0;
   GrabParams.Y_END                 = SensorParams.Ysize_Full - 1;
   GrabParams.REVERSE_Y             = 0;
   GrabParams.BLACK_OFFSET          = 0x0100;     // data_pedestal
   GrabParams.ANALOG_GAIN           = 0x1;        // gain=1
						          
   printf_s("XGS5K Sensor detected, ");
   }




void CXGS_Ctrl::XGS5M_LoadDCF(int lanes) {
      
	XGS_WaitRdy();                          // Wait until the sensor is ready to receive register writes 

	XGS5M_Check_otpm_depended_uploads();    // OTM : timing settings 

	XGS5M_Enable4lanes();               	// No support for other nblane for the moment

	XGS_Activate_sensor();                  // Set slave and external trig

	XGS_Config_Monitor();                   // Config monitor pins

	XGS_CopyMirror_regs();                  // Copy some "mirror" registers from Sensor to FPGA

	XGS_SetConfigFPGA();                    // Confif FPGA registers, Readout_cfg, Exposure during FOT...
}




//-----------------------------------------
// Check if need to optimize XGS register
//-----------------------------------------
const M_UINT32 REG_BURST1[] = { 0x4064, 0x5021, 0x0071, 0x5022, 0x007D, 0x5A21, 0x007D, 0x5F22, 0x007D, 0x5A21, 0x007D, 0x5034, 0x007D, 0x502F, 0x007D, 0x5027, 0x007D, 0x5021, 0x007D, 0x5422, 0x007D, 0x5033, 0x007D, 0x5024, 0x007D, 0x5122, 0x007D, 0x5021, 0x007D, 0x5022, 0x007D, 0x5031, 0x0071, 0x502F, 0x0071, 0x5022, 0x0071, 0x0021, 0x0071, 0x0031, 0x5071, 0x002F, 0x5071, 0x0023, 0x5071, 0x0021, 0x0071, 0xA032, 0x0071, 0xA02B, 0x0071, 0x2021, 0x0071, 0x200F, 0x2071, 0x200A, 0x2071, 0x2001, 0x0071, 0x600B, 0x0071, 0x4001, 0x0071, 0x400F, 0x0871, 0x400A, 0x0871, 0x4001, 0x0071, 0x501F, 0x0071, 0x501B, 0x0071, 0x500F, 0x0071, 0x5001, 0x0070, 0x5001, 0x0072, 0x5000, 0x0072 };
const M_UINT32 REG_BURST2[] = { 0x4104, 0x5001, 0x0072, 0x501A, 0x0072, 0x500D, 0x0072, 0x5001, 0x0070, 0x5032, 0x00F0, 0x5021, 0x00F0, 0x5021, 0x0070, 0x5020, 0x0071 };
const M_UINT32 REG_BURST3[] = { 0x4124, 0x5011, 0x0072, 0x500F, 0x0072, 0x500C, 0x0072, 0x501A, 0x0072, 0x500D, 0x0072, 0x5001, 0x0070, 0x5032, 0x00F0, 0x5021, 0x00F0, 0x5021, 0x0070, 0x5020, 0x0071 };
const M_UINT32 REG_BURST4[] = { 0x414C, 0x501A, 0x0072, 0x500B, 0x0072, 0x501A, 0x0072, 0x500D, 0x0072, 0x5001, 0x0070, 0x5032, 0x00F0, 0x5021, 0x00F0, 0x5021, 0x0070, 0x5020, 0x0071 };
const M_UINT32 REG_BURST5[] = { 0x4170, 0x501F, 0x0072, 0x501F, 0x0072, 0x5013, 0x0072, 0x5007, 0x0072, 0x501A, 0x0072, 0x500D, 0x0072, 0x5001, 0x0070, 0x5032, 0x00F0, 0x5021, 0x00F0, 0x5021, 0x0070, 0x5020, 0x0071 };
const M_UINT32 REG_BURST6[] = { 0x419C, 0x5012, 0x0072, 0x500F, 0x0072, 0x5008, 0x0072, 0x501A, 0x0072, 0x500D, 0x0072, 0x5001, 0x0070, 0x5032, 0x00F0, 0x5021, 0x00F0, 0x5021, 0x0070, 0x5020, 0x0071 };
const M_UINT32 REG_BURST7[] = { 0x5000, 0x5201, 0x2311, 0x007C, 0x0000, 0x5302, 0x2311, 0x007C, 0x0000, 0x5201, 0x2311, 0x007C, 0x0000, 0x5001, 0x2311, 0x007C, 0x0000, 0x5005, 0x3F11, 0x007C, 0x0000, 0x5001, 0x3F19, 0x007C, 0x0000, 0x5002, 0x3F1D, 0x007E, 0x0000, 0x5001, 0x3F19, 0x007E, 0x0000, 0x5002, 0x3F11, 0x007E, 0x0000, 0x5003, 0x3B11, 0x006E, 0x0000, 0x5001, 0x3911, 0x0066, 0x0000, 0x5001, 0x3911, 0x0046, 0x0000, 0x5009, 0x7911, 0x00C6, 0x0000, 0x5018, 0x7111, 0x00C6, 0x0000, 0x5182, 0x7111, 0x00C6, 0x0000, 0x509F, 0x7111, 0x00C6, 0x0000, 0x509A, 0x7111, 0x00C6, 0x0000, 0x509C, 0x6111, 0x00C6, 0x0000, 0x5081, 0x6111, 0x00C6, 0x0000, 0x5881, 0x6111, 0x00C6, 0x0000, 0x5C81, 0x6111, 0x00C7, 0x0000, 0x5C01, 0xE111, 0x00C7, 0x0000, 0x5801, 0xE011, 0x00C5, 0x0000, 0x501B, 0xE011, 0x00C5, 0x0000, 0x5402, 0xE011, 0x00C5, 0x0000, 0x501F, 0xE011, 0x00C5, 0x0000, 0x5001, 0xE011, 0x00C5, 0x0000, 0x5006, 0xE011, 0x00C5, 0x0000, 0x509F, 0x6011, 0x00C5, 0x0000, 0x5088, 0x6011, 0x00C5, 0x0000, 0x5001, 0x6015, 0x0045, 0x0000, 0x5001, 0x6215, 0x006D, 0x0000, 0x5000, 0x5F11, 0x007C, 0x0000 };
const M_UINT32 REG_BURST8[] = { 0x5108, 0x5001, 0x3F11, 0x007C, 0x0000, 0x5082, 0x3F11, 0x007C, 0x0000, 0x5003, 0x3F11, 0x007C, 0x0000, 0x5005, 0x3F11, 0x007E, 0x0000, 0x5003, 0x3B11, 0x006E, 0x0000, 0x5001, 0x3911, 0x0066, 0x0000, 0x5001, 0x3911, 0x0046, 0x0000, 0x5009, 0x7911, 0x00C6, 0x0000, 0x501F, 0x7111, 0x00C6, 0x0000, 0x501F, 0x7111, 0x00C6, 0x0000, 0x5005, 0x7111, 0x00C6, 0x0000, 0x501D, 0x6111, 0x00C6, 0x0000, 0x5001, 0x6111, 0x00C7, 0x0000, 0x5001, 0xE111, 0x00C7, 0x0000, 0x501F, 0xE011, 0x00C5, 0x0000, 0x501A, 0xE011, 0x00C5, 0x0000, 0x5001, 0xE011, 0x00C5, 0x0000, 0x501F, 0x6011, 0x00C5, 0x0000, 0x5019, 0x6011, 0x00C5, 0x0000, 0x5001, 0x6011, 0x00C5, 0x0000, 0x5001, 0x6011, 0x0045, 0x0000, 0x5001, 0x6011, 0x006D, 0x0000, 0x5001, 0x2211, 0x007C, 0x0000, 0x5004, 0x2311, 0x007C, 0x0000, 0x5000, 0x2311, 0x007C, 0x0000 };
const M_UINT32 REG_BURST9[] = { 0x51D0, 0x5201, 0x2F11, 0x007C, 0x0000, 0x5382, 0x2F11, 0x007C, 0x0000, 0x5201, 0x2F11, 0x007C, 0x0000, 0x5006, 0x2F11, 0x007C, 0x0000, 0x5005, 0x3F11, 0x007C, 0x0000, 0x5001, 0x3F19, 0x007C, 0x0000, 0x5002, 0x3F1D, 0x007E, 0x0000, 0x5001, 0x3F19, 0x007E, 0x0000, 0x5006, 0x3F11, 0x007E, 0x0000, 0x501A, 0x3F11, 0x005E, 0x0000, 0x5001, 0x3F11, 0x005E, 0x0000, 0x5102, 0x3F11, 0x005E, 0x0000, 0x501F, 0x3F11, 0x005E, 0x0000, 0x501A, 0x3F11, 0x005E, 0x0000, 0x501C, 0x2F11, 0x005E, 0x0000, 0x5001, 0x2F11, 0x005E, 0x0000, 0x5801, 0x2F11, 0x005E, 0x0000, 0x5C01, 0x2F11, 0x005F, 0x0000, 0x5C01, 0xAF11, 0x005F, 0x0000, 0x5801, 0xAE11, 0x005D, 0x0000, 0x501B, 0xAE11, 0x005D, 0x0000, 0x5402, 0xAE11, 0x005D, 0x0000, 0x501D, 0xAE11, 0x005D, 0x0000, 0x501F, 0x2E11, 0x005D, 0x0000, 0x5019, 0x2E11, 0x005D, 0x0000, 0x5001, 0x2E11, 0x005D, 0x0000, 0x5001, 0x2E15, 0x005D, 0x0000, 0x5001, 0x2E15, 0x007D, 0x0000, 0x5000, 0x2E11, 0x007C, 0x0000};
const M_UINT32 REG_BURST10[] = { 0x6000, 0x0002, 0x001C, 0x0001, 0x0000, 0x0004, 0x0160, 0x0041, 0x0160, 0x0042, 0x0160, 0x0043, 0x0160, 0x0042, 0x0060, 0x0042, 0x1060, 0x0001, 0x1060, 0x0001, 0x9060, 0x0002, 0x9060, 0x0006, 0x9060, 0x0081, 0x9060, 0x0081, 0x1060, 0x0022, 0x1060, 0x0028, 0x1060, 0x0001, 0x1020, 0x0001, 0x1000, 0x2001, 0x1000, 0x0002, 0x1000, 0x0008, 0x1200, 0x0003, 0x1000, 0x0002, 0x1004, 0x0001, 0x5000, 0xC001, 0x5002, 0xE001, 0x5002, 0xC001, 0x7002, 0x8001, 0x5002, 0x8001, 0x5002, 0x8801, 0x5002, 0x8901, 0x5002, 0xBE01, 0x5002, 0x8001, 0x7002, 0xC001, 0x5002, 0x4001, 0x5002, 0x4801, 0x5002, 0x4901, 0x5002, 0x7E01, 0x5002, 0x4001, 0x7002, 0x0001, 0x5002, 0x0001, 0x5002, 0x0801, 0x5002, 0x0901, 0x5002, 0x3E01, 0x5002, 0x0001, 0x7002, 0x4001, 0x5002, 0xC001, 0x5001, 0xC801, 0x5001, 0xC901, 0x5001, 0xFE01, 0x5001, 0xC001, 0x7001, 0x8001, 0x5001, 0x8001, 0x5001, 0x8801, 0x5001, 0x8901, 0x5001, 0xBE01, 0x5001, 0x8001, 0x7001, 0xC001, 0x5001, 0x4001, 0x5001, 0x4901, 0x5001, 0x7E01, 0x5001, 0x4001, 0x7001, 0x0001, 0x5001, 0x0001, 0x5001, 0x0901, 0x5001, 0x3E01, 0x5001, 0x0001, 0x7001, 0x4001, 0x5001, 0xC001, 0x5000, 0xC901, 0x5000, 0xFE01, 0x5000, 0xC001, 0x7000, 0x8001, 0x5000, 0x8001, 0x5000, 0x8901, 0x5000, 0x9E01, 0x5000, 0x8002, 0x5000, 0x0001, 0x1000, 0x0001, 0x100C, 0x0001, 0x106C, 0x001F, 0x1060, 0x0001, 0x1020, 0x0005, 0x1000, 0x8001, 0x5003, 0xA001, 0x1003, 0x8001, 0x1003, 0x8001, 0x1003, 0xC001, 0x1003, 0xC001, 0x3003, 0xC001, 0x1003, 0x4001, 0x1003, 0x4801, 0x1003, 0x4901, 0x1003, 0x7E01, 0x1003, 0x4001, 0x1003, 0x4001, 0x1003, 0x4001, 0x1003, 0x0001, 0x3003, 0x0001, 0x1003, 0x0001, 0x1003, 0x0801, 0x1003, 0x0901, 0x1003, 0x3E01, 0x1003, 0x0001, 0x3003, 0x4001, 0x1003, 0xC001, 0x1002, 0xC801, 0x1002, 0xC901, 0x1002, 0xFE01, 0x1002, 0xC001, 0x3002, 0x8001, 0x1002, 0x8001, 0x1002, 0x8801, 0x1002, 0x8901, 0x1002, 0xBE01, 0x1002, 0x8001, 0x3002, 0xC001, 0x1002, 0x4001, 0x1002, 0x4801, 0x1002, 0x4901, 0x1002, 0x7E01, 0x1002, 0x4001, 0x3002, 0x0001, 0x1002, 0x0001, 0x1002, 0x0801, 0x1002, 0x0901, 0x1002, 0x3E01, 0x1002, 0x0001, 0x3002, 0x4001, 0x1002, 0xC001, 0x1001, 0xC801, 0x1001, 0xC901, 0x1001, 0xFE01, 0x1001, 0xC001, 0x3001, 0x8001, 0x1001, 0x8001, 0x1001, 0x8801, 0x1001, 0x8901, 0x1001, 0xBE01, 0x1001, 0x8001, 0x3001, 0xC001, 0x1001, 0x4001, 0x1001, 0x4901, 0x1001, 0x7E01, 0x1001, 0x4001, 0x3001, 0x0001, 0x1001, 0x0001, 0x1001, 0x0901, 0x1001, 0x3E01, 0x1001, 0x0001, 0x3001, 0x4001, 0x1001, 0xC001, 0x1000, 0xC901, 0x1000, 0xFE01, 0x1000, 0xC001, 0x3000, 0x8001, 0x1000, 0x8001, 0x1000, 0x8901, 0x1000, 0x9E01, 0x1000, 0x8001, 0x1000, 0x0001, 0x1000, 0x0000, 0x1000 };
const M_UINT32 REG_BURST11[] = { 0x6288, 0x0062, 0x011C, 0x007C, 0x0100, 0x0061, 0x0100, 0x00E2, 0x0100, 0x006C, 0x0100, 0x2061, 0x0100, 0x0062, 0x0100, 0x0068, 0x0300, 0x0063, 0x0100, 0x0062, 0x0104, 0x0061, 0x4100, 0xC061, 0x6102, 0xE061, 0x4102, 0xC062, 0x4102, 0x8061, 0x4102, 0x8961, 0x6102, 0xBE61, 0x4102, 0x8062, 0x4102, 0x4061, 0x4102, 0x4961, 0x6102, 0x7E61, 0x4102, 0x4062, 0x4102, 0x0061, 0x4102, 0x0961, 0x6102, 0x3E61, 0x4102, 0x0062, 0x4102, 0xC061, 0x4101, 0xC961, 0x6101, 0xFE61, 0x4101, 0xC062, 0x4101, 0x8061, 0x4101, 0x8961, 0x6101, 0xBE61, 0x4101, 0x8062, 0x4101, 0x4061, 0x4101, 0x4961, 0x6101, 0x7E61, 0x4101, 0x4062, 0x4101, 0x0061, 0x4101, 0x0961, 0x6101, 0x3E61, 0x4101, 0x0062, 0x4101, 0xC061, 0x4100, 0xC961, 0x6100, 0xFE61, 0x4100, 0xC062, 0x4100, 0x8061, 0x4100, 0x8961, 0x4100, 0x9E61, 0x4100, 0x8062, 0x4100, 0x0061, 0x0100, 0x0062, 0x010C, 0x007F, 0x0100, 0x006B, 0x0100, 0x8061, 0x4103, 0xA061, 0x0103, 0x8061, 0x0103, 0x8061, 0x2103, 0x8063, 0x0103, 0x4061, 0x0103, 0x4961, 0x0103, 0x7E61, 0x0103, 0x4061, 0x0103, 0x4061, 0x2103, 0x4063, 0x0103, 0x0061, 0x0103, 0x0961, 0x2103, 0x3E61, 0x0103, 0x0062, 0x0103, 0xC061, 0x0102, 0xC961, 0x2102, 0xFE61, 0x0102, 0xC062, 0x0102, 0x8061, 0x0102, 0x8961, 0x2102, 0xBE61, 0x0102, 0x8062, 0x0102, 0x4061, 0x0102, 0x4961, 0x2102, 0x7E61, 0x0102, 0x4062, 0x0102, 0x0061, 0x0102, 0x0961, 0x2102, 0x3E61, 0x0102, 0x0062, 0x0102, 0xC061, 0x0101, 0xC961, 0x2101, 0xFE61, 0x0101, 0xC062, 0x0101, 0x8061, 0x0101, 0x8961, 0x2101, 0xBE61, 0x0101, 0x8062, 0x0101, 0x4061, 0x0101, 0x4961, 0x2101, 0x7E61, 0x0101, 0x4062, 0x0101, 0x0061, 0x0101, 0x0961, 0x2101, 0x3E61, 0x0101, 0x0062, 0x0101, 0xC061, 0x0100, 0xC961, 0x2100, 0xFE61, 0x0100, 0xC062, 0x0100, 0x8061, 0x0100, 0x8961, 0x0100, 0x9E61, 0x0100, 0x8061, 0x0100, 0x8060, 0x0100 };



void CXGS_Ctrl::XGS5M_Check_otpm_depended_uploads() {

	// Checking the version of OTPM and uploading settings accordingly, reg 0x3700[5] needs to be enabled to read the OTPM version
	// apbase.log("Checking OTPM version (enable register 0x3700[5] = 1) -. reg 0x3016[3:0]")
	WriteSPI(0x3700, 0x0020);
	Sleep(50); //comme ds le code de onsemi
	//otpmversion = reg.reg(0x3016).bitfield(0xF).uncached_value
	M_UINT32 otpmversion = ReadSPI(0x3016);
	printf_s("XGS OTPM version : 0x%X\n", otpmversion);
	WriteSPI(0x3700, 0x0000);
	//Sleep(50);
	if (otpmversion == 0) {

		// [Hidden:Req_Reg_Up_0]
		printf_s("XGS Loading required register uploads\n");

		WriteSPI(0x3992, 0x0001);
		WriteSPI(0x341a, 0x0303);
		WriteSPI(0x340a, 0x2819);
		WriteSPI(0x3816, 0x0004);
		WriteSPI(0x3818, 0x0002);
		WriteSPI(0x391c, 0x6000);
		WriteSPI(0x389a, 0x0802);
		WriteSPI(0x38ea, 0x0041);
		WriteSPI(0x38ec, 0x0041);
		WriteSPI(0x38ee, 0x0041);
		WriteSPI(0x3924, 0x00A2);
		WriteSPI(0x392c, 0x00A2);
		WriteSPI(0x3926, 0x00A2);
		WriteSPI(0x392e, 0x00A2);
		WriteSPI(0x3940, 0x00A2);
		WriteSPI(0x3954, 0x00A2);
		WriteSPI(0x3942, 0x00A2);
		WriteSPI(0x3956, 0x00A2);
		WriteSPI(0x383a, 0x0820);
		WriteSPI(0x395e, 0x004E);
		WriteSPI(0x3966, 0x004F);
		WriteSPI(0x3844, 0x0101);
		WriteSPI(0x341e, 0x101F);
		WriteSPI(0x3420, 0x5F16);
		WriteSPI(0x3424, 0xA7A6);
		WriteSPI(0x3430, 0xB7B6);
		WriteSPI(0x3428, 0xA6B0);
		WriteSPI(0x342a, 0x0000);
		WriteSPI(0x3434, 0xFFFF);


		// [Hidden:Timing_Up]
		printf_s("XGS Loading timing uploads\n");

		WriteSPI_BURST(REG_BURST1,  sizeof(REG_BURST1) / sizeof(M_UINT32));
		WriteSPI_BURST(REG_BURST2,  sizeof(REG_BURST2) / sizeof(M_UINT32));
		WriteSPI_BURST(REG_BURST3,  sizeof(REG_BURST3) / sizeof(M_UINT32));
		WriteSPI_BURST(REG_BURST4,  sizeof(REG_BURST4) / sizeof(M_UINT32));
		WriteSPI_BURST(REG_BURST5,  sizeof(REG_BURST5) / sizeof(M_UINT32));
		WriteSPI_BURST(REG_BURST6,  sizeof(REG_BURST6) / sizeof(M_UINT32));
		WriteSPI_BURST(REG_BURST7,  sizeof(REG_BURST7) / sizeof(M_UINT32));
		WriteSPI_BURST(REG_BURST8,  sizeof(REG_BURST8) / sizeof(M_UINT32));
		WriteSPI_BURST(REG_BURST9,  sizeof(REG_BURST9) / sizeof(M_UINT32));
		WriteSPI_BURST(REG_BURST10, sizeof(REG_BURST10) / sizeof(M_UINT32));
		WriteSPI_BURST(REG_BURST11, sizeof(REG_BURST11) / sizeof(M_UINT32));
		
	}

	if (otpmversion != 0) {
		printf_s("New DCF must be implemented for OTPM version: 0x%X (WIP Last Changed Rev: 17175)\n", otpmversion);
		exit(1);
	}
}


//----------------------------------------------------
// This fonction load specific registers for MUX mode
//----------------------------------------------------
void CXGS_Ctrl::XGS5M_Enable4lanes(void) {

	printf_s("XGS Initializing 4 HiSPI lanes\n");
	// mux mode dependent uploads
	// Loading 4 lanes 12 bit specific settings

	//WriteSPI(0x3810, 0x02DC); // minimum line time 
	WriteSPI(0x3810, (0x02DC) * GrabParams.XGS_LINE_SIZE_FACTOR); // To reduce framerate in PCIe x1, temporairement
	WriteSPI(0x3840, 0x0058);
	WriteSPI(0x3842, 0x017B);
	WriteSPI(0x38C4, 0x0600);
	WriteSPI(0x3A00, 0x000D);
	WriteSPI(0x3A02, 0x0001);
	WriteSPI(0x3E00, 0x0001);
	WriteSPI(0x3E28, 0x2537);
	WriteSPI(0x3E80, 0x000D);


}


