//-----------------------------------------------
//
//  Configuration for XGS5000
//
//  WIP Last Changed Rev : 18962
//    C:\Aptina Imaging\apps_data\XGS5M-REV0.ini 
//    $iris4\athena\bench\XGS_OnSemi_ini_files\XGS5M-REV0.ini   
//-----------------------------------------------

/* Headers */
#include "osincludes.h"

#include "XGS_Ctrl.h"

//Derniere version du microcode de Onsemi pour la famaille XGS5K
M_UINT32 XGS5K_WIP = 18962;


//---------------------------------
// Constants for XGS 5K FOT  
//---------------------------------
// SFOTand EFOT numbers

// SFOT 16 lanes ->
// SFOT 4 lanes  ->
// EFOT 16 lanes ->
// EFOT 4 lanes  ->

//Short Integration time
// SFOT
// EFOT








//-----------------------------------------------
// Init specific 
//-----------------------------------------------
void CXGS_Ctrl::XGS5M_SetGrabParamsInit5000(int lanes, int color)
   {

   SensorParams.SENSOR_TYPE          = 5000;
   SensorParams.XGS_HiSPI_Ch         = 16;
   SensorParams.XGS_HiSPI_Ch_used    = 4;
   SensorParams.XGS_HiSPI_mux        = 4;

   SensorParams.Xsize_Full          = 2600;                                                // Interpolation INCLUDED
   SensorParams.Xsize_Full_valid    = 2592;
   if (color == 0) {
	   SensorParams.XGS_DMA_LinePtrWidth = 2;  //4 line buffers
	   SensorParams.Xstart_valid         = 4;
   }
   else {
	   SensorParams.XGS_DMA_LinePtrWidth = 1;   //2 line buffers
	   SensorParams.Xstart_valid         = 2;   // When color and DPC enabled, then only remove 2 pix
   }

   SensorParams.Ysize_Full          = 2056;                                                // Interpolation INCLUDED
   SensorParams.Ysize_Full_valid    = 2048;
   SensorParams.Ystart_valid        = 4;

   SensorParams.XGS_X_START         = 88;                                                  // MONO : Location of first valid x pixel(including dummies, bl, valid)
   SensorParams.XGS_X_END           = SensorParams.XGS_X_START+ SensorParams.Xsize_Full-1; // MONO : Location of last valid x pixel(including Interpolation, dummies, bl, valid)
   
   SensorParams.XGS_X_SIZE          = 2784;                                                // FULL X, including everything
   SensorParams.XGS_Y_SIZE          = 2078;                                                // FULL Y, including everything (M_LINES as in the SPEC, may be modified with dcf M_LINES PROGRAMMED)

   // This may depend on the configuration (Lanes+LineSize) 

   if (color == 0) {
	   SensorParams.FOTn_2_EXP          = 76800;
	   SensorParams.ReadOutN_2_TrigN    = 51200;
	   SensorParams.TrigN_2_FOT         = 23000 * GrabParams.XGS_LINE_SIZE_FACTOR;
	   SensorParams.EXP_FOT             = 7000;
	   SensorParams.EXP_FOT_TIME        = SensorParams.TrigN_2_FOT + SensorParams.EXP_FOT;  //TOTAL : 23us trig fall to FOT START  + 5.36us calculated from start of FOT to end of real exposure in dev board, to validate!
	   SensorParams.KEEP_OUT_ZONE_START = 0x2bf;
   } 
   else
   {
	   SensorParams.FOTn_2_EXP          = 213600;
	   SensorParams.ReadOutN_2_TrigN    = 188000;
	   SensorParams.TrigN_2_FOT         =  91200;
	   SensorParams.EXP_FOT             = 7000;
	   SensorParams.EXP_FOT_TIME        = SensorParams.TrigN_2_FOT + SensorParams.EXP_FOT;  //TOTAL : 23us trig fall to FOT START  + 5.36us calculated from start of FOT to end of real exposure in dev board, to validate!
	   SensorParams.KEEP_OUT_ZONE_START = 0xb1a; 
   }
   GrabParams.FOT                   = 10; // FOT exprime en nombre de ligne senseur, utilise en mode EO_FOT_SEL=1.

   GrabParams.Y_START               = 0;
   GrabParams.Y_END                 = SensorParams.Ysize_Full - 1;
   GrabParams.BLACK_OFFSET          = 0x0100;     // data_pedestal
   GrabParams.ANALOG_GAIN           = 0x1;        // gain=1
						          
   printf_s("XGS5K Sensor detected, ");
   }


void CXGS_Ctrl::XGS5M_SetGrabParamsInit2000(int lanes, int color)
{

	SensorParams.SENSOR_TYPE          = 2000;
	SensorParams.XGS_HiSPI_Ch         = 16;
	SensorParams.XGS_HiSPI_Ch_used    = 4;
	SensorParams.XGS_HiSPI_mux        = 4;

	SensorParams.Xsize_Full           = 1928;                                                // Interpolation INCLUDED
	SensorParams.Xsize_Full_valid     = 1920;
	if (color == 0) {
		SensorParams.XGS_DMA_LinePtrWidth = 2;  //4 line buffers
		SensorParams.Xstart_valid         = 4;
	}
	else {
		SensorParams.XGS_DMA_LinePtrWidth = 1;   //2 line buffers
		SensorParams.Xstart_valid         = 2;   // When color and DPC enabled, then only remove 2 pix
	}

	SensorParams.Ysize_Full           = 1208;                                                // Interpolation INCLUDED
	SensorParams.Ysize_Full_valid     = 1200;
	SensorParams.Ystart_valid         = 4;

	SensorParams.XGS_X_START = 424;                                                  // MONO : Location of first valid x pixel(including dummies, bl, valid)
	SensorParams.XGS_X_END = SensorParams.XGS_X_START + SensorParams.Xsize_Full - 1; // MONO : Location of last valid x pixel(including interpolation, dummies, bl, valid)

	SensorParams.XGS_X_SIZE = 2784;                                                // FULL X, including everything
	SensorParams.XGS_Y_SIZE = 1230;                                                // FULL Y, including everything (M_LINES as in the SPEC, may be modified with dcf M_LINES PROGRAMMED)

	// This may depend on the configuration (Lanes+LineSize) 
	if (color == 0) {
		SensorParams.FOTn_2_EXP          = 76800;
		SensorParams.ReadOutN_2_TrigN    = 51200;
		SensorParams.TrigN_2_FOT         = 23000 * GrabParams.XGS_LINE_SIZE_FACTOR;
		SensorParams.EXP_FOT             = 7000;
		SensorParams.EXP_FOT_TIME        = SensorParams.TrigN_2_FOT + SensorParams.EXP_FOT;  //TOTAL : 23us trig fall to FOT START  + 5.36us calculated from start of FOT to end of real exposure in dev board, to validate!
		SensorParams.KEEP_OUT_ZONE_START = 0x2bf;
	}
	else
	{
		SensorParams.FOTn_2_EXP          = 213600;
		SensorParams.ReadOutN_2_TrigN    = 188400;
		SensorParams.TrigN_2_FOT         = 91200;
		SensorParams.EXP_FOT             = 7000;
		SensorParams.EXP_FOT_TIME        = SensorParams.TrigN_2_FOT + SensorParams.EXP_FOT;  //TOTAL : 23us trig fall to FOT START  + 5.36us calculated from start of FOT to end of real exposure in dev board, to validate!
		SensorParams.KEEP_OUT_ZONE_START = 0xb1a;
	}

	GrabParams.FOT = 10; // FOT exprime en nombre de ligne senseur, utilise en mode EO_FOT_SEL=1.

	GrabParams.Y_START = 0;
	GrabParams.Y_END = SensorParams.Ysize_Full - 1;
	GrabParams.BLACK_OFFSET = 0x0100;     // data_pedestal
	GrabParams.ANALOG_GAIN = 0x1;        // gain=1

	//printf_s("XGS2M Sensor detected, ");
}



void CXGS_Ctrl::XGS5M_LoadDCF(int lanes) {
      
	XGS_WaitRdy();                          // Wait until the sensor is ready to receive register writes 

	XGS5M_Check_otpm_depended_uploads();    // OTM : timing settings 

	XGS5M_Enable4lanes();               	// No support for other nblane for the moment

	XGS_Activate_sensor();                  // Set slave and external trig

	XGS_Config_Monitor();                   // Config monitor pins

	XGS_CopyMirror_regs();                  // Copy some "mirror" registers from Sensor to FPGA

	XGS_SetConfigFPGA();                    // Confif FPGA registers, Readout_cfg, Exposure during FOT...
}




//-----------------------------------------
// Check if need to optimize XGS register
//-----------------------------------------

void CXGS_Ctrl::XGS5M_Check_otpm_depended_uploads() {

	// Checking the version of OTPM and uploading settings accordingly, reg 0x3700[5] needs to be enabled to read the OTPM version
	// apbase.log("Checking OTPM version (enable register 0x3700[5] = 1) -. reg 0x3016[3:0]")
	WriteSPI(0x3700, 0x0020);
	Sleep(50); //comme ds le code de onsemi
	//otpmversion = reg.reg(0x3016).bitfield(0xF).uncached_value
	M_UINT32 otpmversion = ReadSPI(0x3016);
	printf_s("XGS OTPM version : 0x%X  (WIP Rev: %d)\n", otpmversion, XGS5K_WIP);
	WriteSPI(0x3700, 0x0000);
	//Sleep(50);
	if (otpmversion <= 1) {

		printf_s("\n\nLa version otpm est v%d, load de la version longue de la dcf (WIP Rev: %d)\n", otpmversion, XGS5K_WIP);

		XGS5M_Req_Reg_Up_0();
		printf_s("XGS Loading timing uploads");
		XGS5M_Timing_Up();


	}
	else {
		printf_s("OTPM version: 0x%X (WIP Last Changed Rev: %d), skipping Req_Reg_Up_0 and Timing_Up register load\n", otpmversion, XGS5K_WIP);
		XGS5M_Req_Reg_Up_2();
	}
}


//----------------------------------------------------
// This fonction load specific registers for MUX mode
//----------------------------------------------------
void CXGS_Ctrl::XGS5M_Enable4lanes(void) {

	printf_s("XGS Initializing 4 HiSPI lanes\n");
	// mux mode dependent uploads
	// Loading 4 lanes 12 bit specific settings

	//WriteSPI(0x3810, 0x02DC); // minimum line time 
	WriteSPI(0x3810, (0x02DC) * GrabParams.XGS_LINE_SIZE_FACTOR); // To reduce framerate in PCIe x1, temporairement
	WriteSPI(0x3840, 0x0058);
	WriteSPI(0x3842, 0x017B);
	WriteSPI(0x38C4, 0x0600);
	WriteSPI(0x3A00, 0x000D);
	WriteSPI(0x3A02, 0x0001);
	WriteSPI(0x3E00, 0x0001);
	WriteSPI(0x3E28, 0x2537);
	WriteSPI(0x3E80, 0x000D);


}

void CXGS_Ctrl::XGS5M_Req_Reg_Up_0(void) {

	// [Hidden:Req_Reg_Up_0]
	WriteSPI(0x3992, 0x0001);
	WriteSPI(0x341a, 0x0303);
	WriteSPI(0x340a, 0x2819);
	WriteSPI(0x3816, 0x0004);
	WriteSPI(0x3818, 0x0002);
	WriteSPI(0x391c, 0x6000);
	WriteSPI(0x389a, 0x0802);
	WriteSPI(0x38ea, 0x0069);
	WriteSPI(0x38ec, 0x0069);
	WriteSPI(0x38ee, 0x0069);
	WriteSPI(0x3914, 0x003B);
	WriteSPI(0x3918, 0x003B);
	WriteSPI(0x390c, 0x003B);
	WriteSPI(0x796e, 0x0103);
	WriteSPI(0x7970, 0x0103);
	WriteSPI(0x7972, 0x0103);
	WriteSPI(0x7974, 0x0103);
	WriteSPI(0x7976, 0x0103);
	WriteSPI(0x7978, 0x0103);
	WriteSPI(0x797a, 0x0103);
	WriteSPI(0x797c, 0x0103);
	WriteSPI(0x797e, 0x0103);
	WriteSPI(0x7980, 0x0103);
	WriteSPI(0x7982, 0x0103);
	WriteSPI(0x7984, 0x0103);
	WriteSPI(0x3938, 0x0103);
	WriteSPI(0x393c, 0x0103);
	WriteSPI(0x3944, 0x0103);
	WriteSPI(0x393a, 0x0103);
	WriteSPI(0x393e, 0x0103);
	WriteSPI(0x3946, 0x0103);
	WriteSPI(0x394c, 0x0103);
	WriteSPI(0x3950, 0x0103);
	WriteSPI(0x3958, 0x0103);
	WriteSPI(0x394e, 0x0103);
	WriteSPI(0x3952, 0x0103);
	WriteSPI(0x395a, 0x0103);
	WriteSPI(0x3928, 0x0103);
	WriteSPI(0x3930, 0x0103);
	WriteSPI(0x392a, 0x0103);
	WriteSPI(0x3932, 0x0103);
	WriteSPI(0x3954, 0x0095);
	WriteSPI(0x3956, 0x0095);
	WriteSPI(0x383a, 0x0820);
	WriteSPI(0x395e, 0x004E);
	WriteSPI(0x3966, 0x004F);
	WriteSPI(0x3844, 0x0101);
	WriteSPI(0x341e, 0x101F);
	WriteSPI(0x3420, 0x5F16);
	WriteSPI(0x3424, 0xA7A6);
	WriteSPI(0x3430, 0xB7B6);
	WriteSPI(0x3428, 0xA6B0);
	WriteSPI(0x342a, 0x0000);
	WriteSPI(0x3434, 0xFFFF);
	WriteSPI(0x3934, 0x0103);
	WriteSPI(0x3936, 0x0103);
	WriteSPI(0x3948, 0x0103);
	WriteSPI(0x394a, 0x0103);
	WriteSPI(0x38f0, 0x0000);
	WriteSPI(0x38f2, 0x0000);

	//Updates to fix first frame not saturating in triggered mode(see AND90029 - D). 
	//WIP 18248
	WriteSPI(0x38CE, 0x8000);
	WriteSPI(0x38D6, 0x9FFF);
}

void CXGS_Ctrl::XGS5M_Req_Reg_Up_2(void) {
	//[Hidden:Req_Reg_Up_2]
	//No uploads necessary for OTPM v2->Only lane specific uploads.
}


//-----------
// Timing UP
//-----------
const M_UINT32 REG_BURST1[] = { 0x4064, 0x5021, 0x0071, 0x5022, 0x007D, 0x5A21, 0x007D, 0x5F22, 0x007D, 0x5A21, 0x007D, 0x5034, 0x007D, 0x502F, 0x007D, 0x5027, 0x007D, 0x5021, 0x007D, 0x5422, 0x007D, 0x5033, 0x007D, 0x5024, 0x007D, 0x5122, 0x007D, 0x5021, 0x007D, 0x5022, 0x007D, 0x5031, 0x0071, 0x502F, 0x0071, 0x5022, 0x0071, 0x0021, 0x0071, 0x0031, 0x5071, 0x002F, 0x5071, 0x0023, 0x5071, 0x0021, 0x0071, 0xA032, 0x0071, 0xA02B, 0x0071, 0x2021, 0x0071, 0x200F, 0x2071, 0x200A, 0x2071, 0x2001, 0x0071, 0x600B, 0x0071, 0x4001, 0x0071, 0x400F, 0x0871, 0x400A, 0x0871, 0x4001, 0x0071, 0x501F, 0x0071, 0x501B, 0x0071, 0x500F, 0x0071, 0x5001, 0x0070, 0x5001, 0x0072, 0x5000, 0x0072 };
const M_UINT32 REG_BURST2[] = { 0x41A4, 0x5001, 0x0072, 0x501A, 0x0072, 0x500D, 0x0072, 0x5001, 0x0070, 0x5032, 0x00F0, 0x5021, 0x00F0, 0x5021, 0x0070, 0x5020, 0x0071 };
const M_UINT32 REG_BURST3[] = { 0x417C, 0x5011, 0x0072, 0x500F, 0x0072, 0x500C, 0x0072, 0x501A, 0x0072, 0x500D, 0x0072, 0x5001, 0x0070, 0x5032, 0x00F0, 0x5021, 0x00F0, 0x5021, 0x0070, 0x5020, 0x0071 };
const M_UINT32 REG_BURST4[] = { 0x4104, 0x501A, 0x0072, 0x500B, 0x0072, 0x501A, 0x0072, 0x500D, 0x0072, 0x5001, 0x0070, 0x5032, 0x00F0, 0x5021, 0x00F0, 0x5021, 0x0070, 0x5020, 0x0071 };
const M_UINT32 REG_BURST5[] = { 0x4128, 0x501F, 0x0072, 0x501F, 0x0072, 0x5013, 0x0072, 0x5007, 0x0072, 0x501A, 0x0072, 0x500D, 0x0072, 0x5001, 0x0070, 0x5032, 0x00F0, 0x5021, 0x00F0, 0x5021, 0x0070, 0x5020, 0x0071 };
const M_UINT32 REG_BURST6[] = { 0x4154, 0x5012, 0x0072, 0x500F, 0x0072, 0x5008, 0x0072, 0x501A, 0x0072, 0x500D, 0x0072, 0x5001, 0x0070, 0x5032, 0x00F0, 0x5021, 0x00F0, 0x5021, 0x0070, 0x5020, 0x0071 };
const M_UINT32 REG_BURST7[] = { 0x5000, 0x5201, 0x2311, 0x007C, 0x0000, 0x5302, 0x2311, 0x007C, 0x0000, 0x5201, 0x2311, 0x007C, 0x0000, 0x5001, 0x2311, 0x007C, 0x0000, 0x5005, 0x3F11, 0x007C, 0x0000, 0x5001, 0x3F19, 0x007C, 0x0000, 0x5002, 0x3F1D, 0x007E, 0x0000, 0x5001, 0x3F19, 0x007E, 0x0000, 0x5002, 0x3F11, 0x007E, 0x0000, 0x5003, 0x3B11, 0x006E, 0x0000, 0x5001, 0x3911, 0x0066, 0x0000, 0x5001, 0x3911, 0x0046, 0x0000, 0x5009, 0x7911, 0x00C6, 0x0000, 0x5018, 0x7111, 0x00C6, 0x0000, 0x5182, 0x7111, 0x00C6, 0x0000, 0x509F, 0x7111, 0x00C6, 0x0000, 0x509A, 0x7111, 0x00C6, 0x0000, 0x509C, 0x6111, 0x00C6, 0x0000, 0x5081, 0x6111, 0x00C6, 0x0000, 0x5881, 0x6111, 0x00C6, 0x0000, 0x5C81, 0x6111, 0x00C7, 0x0000, 0x5C01, 0xE111, 0x00C7, 0x0000, 0x5801, 0xE011, 0x00C5, 0x0000, 0x501B, 0xE011, 0x00C5, 0x0000, 0x5402, 0xE011, 0x00C5, 0x0000, 0x501F, 0xE011, 0x00C5, 0x0000, 0x5001, 0xE011, 0x00C5, 0x0000, 0x5006, 0xE011, 0x00C5, 0x0000, 0x509F, 0x6011, 0x00C5, 0x0000, 0x5088, 0x6011, 0x00C5, 0x0000, 0x5001, 0x6015, 0x0045, 0x0000, 0x5001, 0x6215, 0x006D, 0x0000, 0x5000, 0x5F11, 0x007C, 0x0000 };
const M_UINT32 REG_BURST8[] = { 0x5108, 0x5001, 0x3F11, 0x007C, 0x0000, 0x5082, 0x3F11, 0x007C, 0x0000, 0x5003, 0x3F11, 0x007C, 0x0000, 0x5005, 0x3F11, 0x007E, 0x0000, 0x5003, 0x3B11, 0x006E, 0x0000, 0x5001, 0x3911, 0x0066, 0x0000, 0x5001, 0x3911, 0x0046, 0x0000, 0x5009, 0x7911, 0x00C6, 0x0000, 0x501F, 0x7111, 0x00C6, 0x0000, 0x501F, 0x7111, 0x00C6, 0x0000, 0x5005, 0x7111, 0x00C6, 0x0000, 0x501D, 0x6111, 0x00C6, 0x0000, 0x5001, 0x6111, 0x00C7, 0x0000, 0x5001, 0xE111, 0x00C7, 0x0000, 0x501F, 0xE011, 0x00C5, 0x0000, 0x501A, 0xE011, 0x00C5, 0x0000, 0x5001, 0xE011, 0x00C5, 0x0000, 0x501F, 0x6011, 0x00C5, 0x0000, 0x5019, 0x6011, 0x00C5, 0x0000, 0x5001, 0x6011, 0x00C5, 0x0000, 0x5001, 0x6011, 0x0045, 0x0000, 0x5001, 0x6011, 0x006D, 0x0000, 0x5001, 0x2211, 0x007C, 0x0000, 0x5004, 0x2311, 0x007C, 0x0000, 0x5000, 0x2311, 0x007C, 0x0000 };
const M_UINT32 REG_BURST9[] = { 0x51D8, 0x5201, 0x2F11, 0x007C, 0x0000, 0x5382, 0x2F11, 0x007C, 0x0000, 0x5201, 0x2F11, 0x007C, 0x0000, 0x5006, 0x2F11, 0x007C, 0x0000, 0x5005, 0x3F11, 0x007C, 0x0000, 0x5001, 0x3F19, 0x007C, 0x0000, 0x5002, 0x3F1D, 0x007E, 0x0000, 0x5001, 0x3F19, 0x007E, 0x0000, 0x5006, 0x3F11, 0x007E, 0x0000, 0x501A, 0x3F11, 0x005E, 0x0000, 0x5001, 0x3F11, 0x005E, 0x0000, 0x5102, 0x3F11, 0x005E, 0x0000, 0x501F, 0x3F11, 0x005E, 0x0000, 0x501A, 0x3F11, 0x005E, 0x0000, 0x501C, 0x2F11, 0x005E, 0x0000, 0x5001, 0x2F11, 0x005E, 0x0000, 0x5801, 0x2F11, 0x005E, 0x0000, 0x5C01, 0x2F11, 0x005F, 0x0000, 0x5C01, 0xAF11, 0x005F, 0x0000, 0x5801, 0xAE11, 0x005D, 0x0000, 0x501B, 0xAE11, 0x005D, 0x0000, 0x5402, 0xAE11, 0x005D, 0x0000, 0x501D, 0xAE11, 0x005D, 0x0000, 0x501F, 0x2E11, 0x005D, 0x0000, 0x5019, 0x2E11, 0x005D, 0x0000, 0x5001, 0x2E11, 0x005D, 0x0000, 0x5001, 0x2E15, 0x005D, 0x0000, 0x5001, 0x2E15, 0x007D, 0x0000, 0x5000, 0x2E11, 0x007C, 0x0000 };
const M_UINT32 REG_BURST10[] = { 0x640C, 0x0002, 0x001C, 0x0001, 0x0000, 0x0004, 0x0160, 0x0041, 0x0160, 0x0042, 0x0160, 0x0043, 0x0160, 0x0042, 0x0060, 0x0042, 0x1060, 0x0001, 0x1060, 0x0001, 0x9060, 0x0002, 0x9060, 0x0006, 0x9060, 0x0081, 0x9060, 0x0081, 0x1060, 0x0022, 0x1060, 0x0028, 0x1060, 0x0001, 0x1020, 0x0001, 0x1000, 0x2001, 0x1000, 0x0002, 0x1000, 0x0008, 0x1200, 0x0003, 0x1000, 0x0002, 0x1004, 0x0001, 0x5000, 0xC001, 0x5002, 0xE001, 0x5002, 0xC001, 0x7002, 0x8001, 0x5002, 0x8001, 0x5002, 0x8801, 0x5002, 0x8901, 0x5002, 0xBE01, 0x5002, 0x8001, 0x7002, 0xC001, 0x5002, 0x4001, 0x5002, 0x4801, 0x5002, 0x4901, 0x5002, 0x7E01, 0x5002, 0x4001, 0x7002, 0x0001, 0x5002, 0x0001, 0x5002, 0x0801, 0x5002, 0x0901, 0x5002, 0x3E01, 0x5002, 0x0001, 0x7002, 0x4001, 0x5002, 0xC001, 0x5001, 0xC801, 0x5001, 0xC901, 0x5001, 0xFE01, 0x5001, 0xC001, 0x7001, 0x8001, 0x5001, 0x8001, 0x5001, 0x8801, 0x5001, 0x8901, 0x5001, 0xBE01, 0x5001, 0x8001, 0x7001, 0xC001, 0x5001, 0x4001, 0x5001, 0x4901, 0x5001, 0x7E01, 0x5001, 0x4001, 0x7001, 0x0001, 0x5001, 0x0001, 0x5001, 0x0901, 0x5001, 0x3E01, 0x5001, 0x0001, 0x7001, 0x4001, 0x5001, 0xC001, 0x5000, 0xC901, 0x5000, 0xFE01, 0x5000, 0xC001, 0x7000, 0x8001, 0x5000, 0x8001, 0x5000, 0x8901, 0x5000, 0x9E01, 0x5000, 0x8002, 0x5000, 0x0001, 0x1000, 0x0001, 0x100C, 0x0001, 0x106C, 0x001F, 0x1060, 0x0001, 0x1020, 0x0005, 0x1000, 0x8001, 0x5003, 0xA001, 0x1003, 0x8001, 0x1003, 0x8001, 0x1003, 0xC001, 0x1003, 0xC001, 0x3003, 0xC001, 0x1003, 0x4001, 0x1003, 0x4801, 0x1003, 0x4901, 0x1003, 0x7E01, 0x1003, 0x4001, 0x1003, 0x4001, 0x1003, 0x4001, 0x1003, 0x0001, 0x3003, 0x0001, 0x1003, 0x0001, 0x1003, 0x0801, 0x1003, 0x0901, 0x1003, 0x3E01, 0x1003, 0x0001, 0x3003, 0x4001, 0x1003, 0xC001, 0x1002, 0xC801, 0x1002, 0xC901, 0x1002, 0xFE01, 0x1002, 0xC001, 0x3002, 0x8001, 0x1002, 0x8001, 0x1002, 0x8801, 0x1002, 0x8901, 0x1002, 0xBE01, 0x1002, 0x8001, 0x3002, 0xC001, 0x1002, 0x4001, 0x1002, 0x4801, 0x1002, 0x4901, 0x1002, 0x7E01, 0x1002, 0x4001, 0x3002, 0x0001, 0x1002, 0x0001, 0x1002, 0x0801, 0x1002, 0x0901, 0x1002, 0x3E01, 0x1002, 0x0001, 0x3002, 0x4001, 0x1002, 0xC001, 0x1001, 0xC801, 0x1001, 0xC901, 0x1001, 0xFE01, 0x1001, 0xC001, 0x3001, 0x8001, 0x1001, 0x8001, 0x1001, 0x8801, 0x1001, 0x8901, 0x1001, 0xBE01, 0x1001, 0x8001, 0x3001, 0xC001, 0x1001, 0x4001, 0x1001, 0x4901, 0x1001, 0x7E01, 0x1001, 0x4001, 0x3001, 0x0001, 0x1001, 0x0001, 0x1001, 0x0901, 0x1001, 0x3E01, 0x1001, 0x0001, 0x3001, 0x4001, 0x1001, 0xC001, 0x1000, 0xC901, 0x1000, 0xFE01, 0x1000, 0xC001, 0x3000, 0x8001, 0x1000, 0x8001, 0x1000, 0x8901, 0x1000, 0x9E01, 0x1000, 0x8001, 0x1000, 0x0001, 0x1000, 0x0000, 0x1000 };


void CXGS_Ctrl::XGS5M_Timing_Up(void) {
	// [Hidden:Timing_Up]
	WriteSPI_BURST(REG_BURST1, sizeof(REG_BURST1) / sizeof(M_UINT32));
	WriteSPI_BURST(REG_BURST2, sizeof(REG_BURST2) / sizeof(M_UINT32));
	WriteSPI_BURST(REG_BURST3, sizeof(REG_BURST3) / sizeof(M_UINT32));
	WriteSPI_BURST(REG_BURST4, sizeof(REG_BURST4) / sizeof(M_UINT32));
	WriteSPI_BURST(REG_BURST5, sizeof(REG_BURST5) / sizeof(M_UINT32));
	WriteSPI_BURST(REG_BURST6, sizeof(REG_BURST6) / sizeof(M_UINT32));
	WriteSPI_BURST(REG_BURST7, sizeof(REG_BURST7) / sizeof(M_UINT32));
	WriteSPI_BURST(REG_BURST8, sizeof(REG_BURST8) / sizeof(M_UINT32));
	WriteSPI_BURST(REG_BURST9, sizeof(REG_BURST9) / sizeof(M_UINT32));
	WriteSPI_BURST(REG_BURST10, sizeof(REG_BURST10) / sizeof(M_UINT32));
}
