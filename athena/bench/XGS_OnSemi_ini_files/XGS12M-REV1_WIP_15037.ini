; WIP Last Changed Rev: 15037
;**************************************************************************************       
; Copyright 2017 ON Semiconductor. All rights reserved.                             
;                                                                                             
;                                                                                             
; No permission to use, copy, modify, or distribute this software and/or                      
; its documentation for any purpose has been granted by ON Semiconductor.           
; If any such permission has been granted ( by separate agreement ), it                       
; is required that the above copyright notice appear in all copies and                        
; that both that copyright notice and this permission notice appear in                        
; supporting documentation, and that the name of ON Semiconductor or any            
; of its trademarks may not be used in advertising or publicity pertaining                    
; to distribution of the software without specific, written prior permission.                 
;                                                                                             
;                                                                                             
;      This software and any associated documentation are provided "AS IS" and                
;      without warranty of any kind.   ON Semiconductor ExPRESSLY DISCLAIMS         
;      ALL WARRANTIES ExPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO, NONINFRINGEMENT       
;      OF THIRD PARTY RIGHTS, AND ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS        
;      FOR A PARTICULAR PURPOSE.  ON Semiconductor DOES NOT WARRANT THAT THE FUNCTIONS CONTAINED        
;      IN THIS SOFTWARE WILL MEET YOUR REQUIREMENTS, OR THAT THE OPERATION OF THIS SOFTWARE   
;      WILL BE UNINTERRUPTED OR ERROR-FREE.  FURTHERMORE, ON Semiconductor DOES NOT WARRANT OR          
;      MAKE ANY REPRESENTATIONS REGARDING THE USE OR THE RESULTS OF THE USE OF ANY            
;      ACCOMPANYING DOCUMENTATION IN TERMS OF ITS CORRECTNESS, ACCURACY, RELIABILITY,         
;      OR OTHERWISE.                                                                          
;*************************************************************************************/       
; Default INI file for XGS12M REV1 (Chip ID 0x0058)
;
; $Revision: 52431 $
; $Date: 2019-03-04 10:03:03 -0800 (Mon, 04 Mar 2019) $
;
; This file holds groups of register presets (sections) specific for this sensor. The
; presets allow you to overwrite the power-on default settings with optimized register
; settings.
; The [Demo Initialization] section contains all optimized register settings for running
; the sensor in the demo environment. Other sections include settings optimized for a
; variety of situations like: Running at different master clock speeds, running under
; different lighting situations, running with different lenses, etc.
; Most of the demonstration software (DevWare, SensorDemo, ...) make use of this file
; to load and store the user presets.
;
; Keyname description:
; REG      = assign a new register value for an address defined in the xsdat file.
; BITFIELD = do a READ-MODIFY-WRITE to part of a register. The part is defined as a mask.
; FIELD_WR = Write any register, variable or bitfield, specified by its symbol name
; LOAD     = load an alternate section from this section
; STATE    = set non-register state
; DELAY    = delay a certain amount of milliseconds before continuing
; POLL_REG = Read a register a specified number of times, or until the register
;            value no longer meets a specified condition. You specify the
;            register by its address, and it only works with simple registers.
;            You also specify a delay between each iteration of the loop.
; POLL_FIELD = Like POLL_REG except you specify the register by its symbol name
;            as defined in the sensor data file. POLL_FIELD works with any kind
;            of register or variable.
;
; Keyname format:
; REG_BURST= [<page>,] <address>, <value>             //<comment>
; BITFIELD = [<page>,] <address>, <mask>, <value>
;            Some examples:
;            BITFIELD=2, 0x05, 0x0020, 1 //for register 5 on page 2, set the 6th bit to 1
;            BITFIELD=0x06, 0x000F, 0    //for register 6, clear the first 4 bits
; FIELD_WR = <registername>, [<bitfieldname>,] <value>
; LOAD     = <section>
; STATE    = <state>, <value>
; DELAY    = <milliseconds>
; POLL_REG = [<page>,]<address>,<mask>,<condition>,DELAY=<milliseconds>,TIMEOUT=<count> //<comment>
;            Example:  Poll every 50ms, stop when value <= 8 or after 5 times (250ms).
;            POLL_REG= 2, 0x3F, 0xFFFF, >8, DELAY=50, TIMEOUT=5
; POLL_FIELD = <registername>, [<bitfieldname>,] <condition>, DELAY=<milliseconds>, TIMEOUT=<count> //<comment>
;            Example:  Poll every 10 ms, stop when the value = 0, or after 500ms.
;            POLL_FIELD = SEQ_CMD, !=0, DELAY=10, TIMEOUT=50
;
; <page>         Optional address space for this register. Some sensors (mostly SOC's)
;                have multiple register pages (see the sensor spec or developer's guide)
; <address>      the register address
; <value>        the new value to assign to the register
; <mask>         is the part of a register value that needs to be updated with a new value
; <registername> Name of a register or variable as defined the sensor data (.sdat) file
; <bitfieldname> Optional name of a bitfield
; <condition>    <  <=  ==  !=  >  or  >=  followed by a numerical value
; <count>        Number of iterations of the polling loop
; <section>      the name of another section to load
; <state>        non-register program state names [do not modify]
; <milliseconds> wait for this ammount of milliseconds before continuing
; <comment>      Some form of C-style comments are supported in this .ini file
;
;*************************************************************************************/

[Demo Initialization]
OPTION = "User Toolbar Show" , 1
OPTION = "User Toolbar2 Show" , 1
OPTION = "Register Log Show" , 1
PROMPT = "How many lanes for your demo?", "6 lanes",LOAD=Initialize 6 Lanes, "12 lanes",LOAD=Initialize 12 Lanes, "18 lanes",LOAD=Initialize 18 Lanes, "24 lanes",LOAD=Initialize 24 Lanes,
PROMPT = "Which mode are you using?", "Non-Triggered",LOAD=empty, "Triggered Mode",LOAD=Triggered_Mode
PROMPT = "Do you want companding?", "No",LOAD=empty, "Yes",LOAD=Python: EnableCompanding
LOAD = python: check_color

REG = 0x3800 , 0x0001

[Initialize 6 Lanes]
LOAD = hwReset
REG = 0x3700 , 0x1
DELAY = 25
REG = 0x3700 , 0x0
DELAY = 25
REG = 0x3700 , 0x001c
POLL_REG = 0x3706, 0x00FF, !=0xEB, DELAY=25, TIMEOUT=500

LOAD = Req_Reg_Up
LOAD = FSM_Up
LOAD= Enable6lanes
LOAD = LSM_Up
LOAD = ALSM_Up
LOAD = SetMonitorOn
		
[Initialize 12 Lanes]
LOAD = hwReset
REG = 0x3700 , 0x1
DELAY = 25
REG = 0x3700 , 0x0
DELAY = 25
REG = 0x3700 , 0x001c
POLL_REG = 0x3706, 0x00FF, !=0xEB, DELAY=25, TIMEOUT=500

LOAD = Req_Reg_Up
LOAD = FSM_Up
LOAD = Enable12lanes
LOAD = LSM_Up
LOAD = ALSM_Up
LOAD = SetMonitorOn
	
[Initialize 18 Lanes]
LOAD = hwReset
REG = 0x3700 , 0x1
DELAY = 25
REG = 0x3700 , 0x0
DELAY = 25
REG = 0x3700 , 0x001c
POLL_REG = 0x3706, 0x00FF, !=0xEB, DELAY=25, TIMEOUT=500

LOAD = Req_Reg_Up
LOAD = FSM_Up
LOAD = Enable18lanes
LOAD = LSM_Up
LOAD = ALSM_Up
LOAD = SetMonitorOn

[Initialize 24 Lanes]
LOAD = hwReset
REG = 0x3700 , 0x1
DELAY = 25
REG = 0x3700 , 0x0
DELAY = 25
REG = 0x3700 , 0x001c
POLL_REG = 0x3706, 0x00FF, !=0xEB, DELAY=25, TIMEOUT=500

LOAD = Req_Reg_Up
LOAD = FSM_Up
LOAD = Enable24lanes
LOAD = LSM_Up
LOAD = ALSM_Up
LOAD = SetMonitorOn

[Toolbar: Sensor Power Cycle]
TOOLTIP = "Toggle Sensor board power"
PYTHON= devware.stop(True)
LOAD = PwrCycle
PYTHON= devware.stop(False)

[Toolbar: Sensor Reset]
TOOLTIP = "Toggle Sensor RESET (external pin)"
PYTHON= devware.stop(True)
LOAD = hwReset
PYTHON= devware.stop(False)

[Toolbar: Reg Dump]
PYTHON= devware.stop(True)
FIELD_WR = GENERAL_CONFIG0_REG , ENABLE , 0x0	// Disable sequencer
SAVE_REGS = register_dump.ini
FIELD_WR = GENERAL_CONFIG0_REG , ENABLE , 0x1	// Enable sequencer
PYTHON= devware.stop(False)

[Hidden: Req_Reg_Up]
REG = 0x3402, 0x0D0D

REG = 0x341A, 0x0303
REG = 0x341E, 0x101F

REG = 0x3420, 0x5F16
REG = 0x3424, 0xA7A6

REG = 0x3434, 0xFFFF

REG = 0x3816, 0x0004
REG = 0x3818, 0x0002
REG = 0x381C, 0x0302

REG = 0x383A, 0x0C34

REG = 0x3840, 0x01BC 
REG = 0x3842, 0x0031
REG = 0x3844, 0x0100

REG = 0x38AC, 0x1602

REG = 0x38C6, 0x0A0A
REG = 0x38C8, 0x000A
REG = 0x38CA, 0x0404
REG = 0x38CC, 0x0004

REG = 0x38E2, 0x0000
REG = 0x38E4, 0x0019
REG = 0x38E6, 0x0019
REG = 0x38E8, 0x0019
REG = 0x38EA, 0x003E
REG = 0x38EC, 0x003E
REG = 0x38EE, 0x003E

REG = 0x3906, 0x0021
REG = 0x390C, 0x003A

REG = 0x3914, 0x003A
REG = 0x3916, 0x0000
REG = 0x3918, 0x003A
REG = 0x391A, 0x0000
REG = 0x391C, 0x6000

REG = 0x3924, 0x0095
REG = 0x3926, 0x0095
REG = 0x3928, 0x0000
REG = 0x392A, 0x0000
REG = 0x392C, 0x0095
REG = 0x392E, 0x0095
REG = 0x3930, 0x0000
REG = 0x3932, 0x0000

REG = 0x3940, 0x0095
REG = 0x3942, 0x0095

REG = 0x395E, 0x004B

REG = 0x3990, 0x2490
REG = 0x3992, 0x0003


[Hidden: FSM_Up]
//FSM initFOT
REG_BURST = 0x4000,  0x0001, 0x817C, 0x0012, 0xA97C, 0x000F, 0xA97C, 0x000C, 0xA97C, 0x0001, 0x817C, 0x501F, 0x817C, 0x501F, 0x817C, 0x5017, 0x817C, 0x500F, 0x817C, 0x5A01, 0x817C, 0x5F02, 0x817C, 0x5A01, 0x817C, 0x501F, 0x817C, 0x501F, 0x817C, 0x501F, 0x817C, 0x501F, 0x817C, 0x501F, 0x817C, 0x5015, 0x817C, 0x500F, 0x817C, 0x500F, 0x817C, 0x5001, 0x817C, 0x5502, 0x817C, 0x501A, 0x817C, 0x5008, 0x817C, 0x5000, 0x817C

//FSM eFOT
REG_BURST = 0x4064,  0x5021, 0x0071, 0x5022, 0x007d, 0x5a21, 0x007d, 0x5f22, 0x007d, 0x5a21, 0x007d, 0x5034, 0x007d, 0x502f, 0x007d, 0x5027, 0x007d, 0x5021, 0x007d, 0x5522, 0x007d, 0x5021, 0x007d, 0x5022, 0x007d, 0x5031, 0x0071, 0x502f, 0x0071, 0x5022, 0x0071, 0x0021, 0x0071, 0x0031, 0x5071, 0x002f, 0x5071, 0x0023, 0x5071, 0x0021, 0x0071, 0xa032, 0x0071, 0xa02b, 0x0071, 0x2021, 0x0071, 0x200f, 0x2071, 0x200a, 0x2071, 0x2001, 0x0071, 0x600b, 0x0071, 0x4001, 0x0071, 0x400f, 0x0871, 0x400a, 0x0871, 0x4001, 0x0071, 0x501f, 0x0071, 0x501b, 0x0071, 0x500f, 0x0071, 0x5001, 0x0070, 0x5001, 0x0072, 0x5000, 0x0072

[Hidden: LSM_Up]
//LSM Active
//The majority of the timing file is taken from ROM - address 0x5000 to 0x50C4
//Only a limited set of values is modified
REG = 0x5006, 0x5302

REG = 0x5012, 0x5001

REG = 0x5054, 0x5182
REG = 0x505A, 0x509F
REG = 0x5060, 0x5098
REG = 0x5066, 0x5081
REG = 0x506C, 0x509C
REG = 0x5072, 0x5081
REG = 0x5078, 0x5881
REG = 0x507E, 0x5c81

REG = 0x50A2, 0x5006
REG = 0x50A4, 0xE011

REG = 0x50A8, 0x509F

REG = 0x50AE, 0x508D

REG = 0x50BC, 0x6215

REG = 0x50C0, 0x5000
REG = 0x50C2, 0x5F11

//LSM X 
REG_BURST = 0x50C6, 0x5001, 0x3F11, 0x007C, 0x5082, 0x3F11, 0x007C, 0x5003, 0x3F11, 0x007C, 0x5005, 0x3F11, 0x007E, 0x5003, 0x3B11, 0x006E, 0x5001, 0x3911, 0x0066, 0x5001, 0x3911, 0x0046, 0x5009, 0x7911, 0x00C6, 0x501F, 0x7111, 0x00C6, 0x501F, 0x7111, 0x00C6, 0x5005, 0x7111, 0x00C6, 0x501D, 0x6111, 0x00C6, 0x5001, 0x6111, 0x00C7, 0x5001, 0xE111, 0x00C7, 0x501F, 0xE011, 0x00C5, 0x501A, 0xE011, 0x00C5, 0x5001, 0xE011, 0x00C5, 0x501F, 0x6011, 0x00C5, 0x5019, 0x6011, 0x00C5, 0x5001, 0x6011, 0x00C5, 0x5001, 0x6011, 0x0045, 0x5001, 0x6011, 0x006D, 0x5001, 0x2211, 0x007C, 0x5004, 0x2311, 0x007C, 0x5000, 0x2311, 0x007C

//LSM CP0 startup
REG_BURST = 0x515C, 0x5201, 0x2F11, 0x007C, 0x5382, 0x2F11, 0x007C, 0x5201, 0x2F11, 0x007C, 0x5006, 0x2F11, 0x007C, 0x5005, 0x3F11, 0x007C, 0x5001, 0x3F19, 0x007C, 0x5002, 0x3F1D, 0x007E, 0x5001, 0x3F19, 0x007E, 0x5006, 0x3F11, 0x007E, 0x501A, 0x3F11, 0x005E, 0x5001, 0x3F11, 0x005E, 0x5102, 0x3F11, 0x005E, 0x501F, 0x3F11, 0x005E, 0x5018, 0x3F11, 0x005E, 0x5001, 0x3F11, 0x005E, 0x501C, 0x2F11, 0x005E, 0x5001, 0x2F11, 0x005E, 0x5801, 0x2F11, 0x005E, 0x5C01, 0x2F11, 0x005F, 0x5C01, 0xAF11, 0x005F, 0x5801, 0xAE11, 0x005D, 0x501B, 0xAE11, 0x005D, 0x5402, 0xAE11, 0x005D, 0x501D, 0xAE11, 0x005D, 0x501F, 0x2E11, 0x005D, 0x5019, 0x2E11, 0x005D, 0x5001, 0x2E11, 0x005D, 0x5001, 0x2E15, 0x005D, 0x5001, 0x2E15, 0x007D, 0x5000, 0x2E11, 0x007C

[Hidden: ALSM_Up]
//ALSM Active
REG_BURST = 0x6000, 0x0002, 0x001C, 0x0001, 0x0000, 0x0004, 0x0160, 0x0041, 0x0160, 0x0042, 0x0160, 0x0043, 0x0160, 0x0042, 0x0060, 0x0042, 0x1060, 0x0001, 0x1060, 0x0001, 0x9060, 0x0002, 0x9060, 0x0006, 0x9060, 0x0081, 0x9060, 0x0081, 0x1060, 0x0022, 0x1060, 0x0028, 0x1060, 0x0001, 0x1020, 0x0001, 0x1000, 0x2001, 0x1000, 0x0002, 0x1000, 0x0008, 0x1200, 0x0003, 0x1000, 0x0002, 0x1004, 0x0001, 0x5000, 0xC001, 0x5002, 0xE001, 0x5002, 0xC001, 0x7002, 0x8001, 0x5002, 0x8001, 0x5002, 0x8901, 0x5002, 0xBE01, 0x5002, 0x8001, 0x7002, 0xC001, 0x5002, 0x4001, 0x5002, 0x4901, 0x5002, 0x7E01, 0x5002, 0x4001, 0x7002, 0x0001, 0x5002, 0x0001, 0x5002, 0x0901, 0x5002, 0x3E01, 0x5002, 0x0001, 0x7002, 0x4001, 0x5002, 0xC001, 0x5001, 0xC901, 0x5001, 0xFE01, 0x5001, 0xC001, 0x7001, 0x8001, 0x5001, 0x8001, 0x5001, 0x8901, 0x5001, 0xBE01, 0x5001, 0x8001, 0x7001, 0xC001, 0x5001, 0x4001, 0x5001, 0x4901, 0x5001, 0x7E01, 0x5001, 0x4001, 0x7001, 0x0001, 0x5001, 0x0001, 0x5001, 0x0901, 0x5001, 0x3E01, 0x5001, 0x0001, 0x7001, 0x4001, 0x5001, 0xC001, 0x5000, 0xC901, 0x5000, 0xFE01, 0x5000, 0xC001, 0x7000, 0x8001, 0x5000, 0x8001, 0x5000, 0x8901, 0x5000, 0x9E01, 0x5000, 0x8002, 0x5000, 0x0001, 0x1000, 0x0001, 0x100C, 0x0001, 0x106C, 0x001F, 0x1060, 0x0005, 0x1060, 0x0001, 0x1020, 0x0005, 0x1000, 0x8001, 0x5003, 0xA001, 0x1003, 0x8001, 0x1003, 0x8001, 0x1003, 0xC001, 0x1003, 0xC001, 0x3003, 0xC001, 0x1003, 0x4001, 0x1003, 0x4901, 0x1003, 0x7E01, 0x1003, 0x4001, 0x1003, 0x4001, 0x1003, 0x4001, 0x1003, 0x0001, 0x3003, 0x0001, 0x1003, 0x0001, 0x1003, 0x0901, 0x1003, 0x3E01, 0x1003, 0x0001, 0x3003, 0x4001, 0x1003, 0xC001, 0x1002, 0xC901, 0x1002, 0xFE01, 0x1002, 0xC001, 0x3002, 0x8001, 0x1002, 0x8001, 0x1002, 0x8901, 0x1002, 0xBE01, 0x1002, 0x8001, 0x3002, 0xC001, 0x1002, 0x4001, 0x1002, 0x4901, 0x1002, 0x7E01, 0x1002, 0x4001, 0x3002, 0x0001, 0x1002, 0x0001, 0x1002, 0x0901, 0x1002, 0x3E01, 0x1002, 0x0001, 0x3002, 0x4001, 0x1002, 0xC001, 0x1001, 0xC901, 0x1001, 0xFE01, 0x1001, 0xC001, 0x3001, 0x8001, 0x1001, 0x8001, 0x1001, 0x8901, 0x1001, 0xBE01, 0x1001, 0x8001, 0x3001, 0xC001, 0x1001, 0x4001, 0x1001, 0x4901, 0x1001, 0x7E01, 0x1001, 0x4001, 0x3001, 0x0001, 0x1001, 0x0001, 0x1001, 0x0901, 0x1001, 0x3E01, 0x1001, 0x0001, 0x3001, 0x4001, 0x1001, 0xC001, 0x1000, 0xC901, 0x1000, 0xFE01, 0x1000, 0xC001, 0x3000, 0x8001, 0x1000, 0x8001, 0x1000, 0x8901, 0x1000, 0x9E01, 0x1000, 0x8001, 0x1000, 0x0000, 0x1000

//ALSM CP0 Startup
REG_BURST = 0x6254, 0x0062, 0x011C, 0x007C, 0x0100, 0x0061, 0x0100, 0x00E2, 0x0100, 0x006C, 0x0100, 0x2061, 0x0100, 0x0062, 0x0100, 0x0068, 0x0300, 0x0063, 0x0100, 0x0062, 0x0104, 0x0061, 0x4100, 0xC061, 0x6102, 0xE061, 0x4102, 0xC062, 0x4102, 0x8061, 0x4102, 0x8961, 0x6102, 0xBE61, 0x4102, 0x8062, 0x4102, 0x4061, 0x4102, 0x4961, 0x6102, 0x7E61, 0x4102, 0x4062, 0x4102, 0x0061, 0x4102, 0x0961, 0x6102, 0x3E61, 0x4102, 0x0062, 0x4102, 0xC061, 0x4101, 0xC961, 0x6101, 0xFE61, 0x4101, 0xC062, 0x4101, 0x8061, 0x4101, 0x8961, 0x6101, 0xBE61, 0x4101, 0x8062, 0x4101, 0x4061, 0x4101, 0x4961, 0x6101, 0x7E61, 0x4101, 0x4062, 0x4101, 0x0061, 0x4101, 0x0961, 0x6101, 0x3E61, 0x4101, 0x0062, 0x4101, 0xC061, 0x4100, 0xC961, 0x6100, 0xFE61, 0x4100, 0xC062, 0x4100, 0x8061, 0x4100, 0x8961, 0x4100, 0x9E61, 0x4100, 0x8062, 0x4100, 0x0061, 0x0100, 0x0062, 0x010C, 0x007F, 0x0100, 0x006B, 0x0100, 0x8061, 0x4103, 0xA061, 0x0103, 0x8061, 0x0103, 0x8061, 0x2103, 0x8063, 0x0103, 0x4061, 0x0103, 0x4961, 0x0103, 0x7E61, 0x0103, 0x4061, 0x0103, 0x4061, 0x2103, 0x4063, 0x0103, 0x0061, 0x0103, 0x0961, 0x2103, 0x3E61, 0x0103, 0x0062, 0x0103, 0xC061, 0x0102, 0xC961, 0x2102, 0xFE61, 0x0102, 0xC062, 0x0102, 0x8061, 0x0102, 0x8961, 0x2102, 0xBE61, 0x0102, 0x8062, 0x0102, 0x4061, 0x0102, 0x4961, 0x2102, 0x7E61, 0x0102, 0x4062, 0x0102, 0x0061, 0x0102, 0x0961, 0x2102, 0x3E61, 0x0102, 0x0062, 0x0102, 0xC061, 0x0101, 0xC961, 0x2101, 0xFE61, 0x0101, 0xC062, 0x0101, 0x8061, 0x0101, 0x8961, 0x2101, 0xBE61, 0x0101, 0x8062, 0x0101, 0x4061, 0x0101, 0x4961, 0x2101, 0x7E61, 0x0101, 0x4062, 0x0101, 0x0061, 0x0101, 0x0961, 0x2101, 0x3E61, 0x0101, 0x0062, 0x0101, 0xC061, 0x0100, 0xC961, 0x2100, 0xFE61, 0x0100, 0xC062, 0x0100, 0x8061, 0x0100, 0x8961, 0x0100, 0x9E61, 0x0100, 0x8061, 0x0100, 0x8060, 0x0100	


[Hidden: hwReset]
LOG = Performing sensor hw reset...
STATE = Sensor Reset, 1 // Activate RESET_B signal
DELAY = 50
STATE = Sensor Reset, 0 // Deactivate RESET_B signal
DELAY = 100
LOG = Reset complete!

[Hidden: PwrCycle]
PROMPT = "Power cycling the sensor board will reset all registers. Press OK to continue, Close this window to abort"
LOG = Power cycling sensor board...
STATE = Sensor Reset, 1 // Activate RESET_B signal
DELAY = 50
STATE = Sensor Power, 0 // Power Down Sensor Board
DELAY = 50
STATE = Sensor Power, 1 // Power Up Sensor Board
DELAY = 50
STATE = Sensor Reset, 0 // Deactivate RESET_B signal
DELAY = 50
LOG = Power cycling complete!


[Hidden: SetMonitorOn]
REG = 0x3602, 0x0092
REG = 0x3806, 0x5446
[Hidden: SetMonitorOff]
REG = 0x3602, 0x0000
REG = 0x3806, 0x0000
[Hidden: Enable24lanes]
REG = 0x3810, 0x00E6 //line time
REG = 0x38C4, 0x1300

REG = 0x3A00, 0x000A
REG = 0x3A02, 0x0001

REG = 0x3E00, 0x0008
REG = 0x3E28, 0x250F
REG = 0x3E80, 0x0001

//Initialize FSM sFOT for 24 lane operation
REG_BURST = 0x40F8, 0x5011, 0x0072, 0x500f, 0x0072, 0x500c, 0x0072, 0x501a, 0x0072, 0x500d, 0x0072, 0x5001, 0x0070, 0x5032, 0x00f0, 0x5021, 0x00f0, 0x5021, 0x0070, 0x5020, 0x0071

[Hidden: Enable18lanes]
REG = 0x3810, 0x00F4 // line time
REG = 0x38C4, 0x1200

REG = 0x3A00, 0x000C
REG = 0x3A02, 0x0001

REG = 0x3E00, 0x0006
REG = 0x3E28, 0x251F
REG = 0x3E80, 0x0005

//Initialize FSM sFOT for 18 lane operation
REG_BURST = 0x40F8, 0x5012, 0x0072, 0x500f, 0x0072, 0x5008, 0x0072, 0x501a, 0x0072, 0x500d, 0x0072, 0x5001, 0x0070, 0x5032, 0x00f0, 0x5021, 0x00f0, 0x5021, 0x0070, 0x5020, 0x0071

[Hidden: Enable12lanes]

REG = 0x3810, 0x016E // line time
REG = 0x38C4, 0x0C00

REG = 0x3A00 , 0x000A
REG = 0x3A02 , 0x0004

REG = 0x3E00 , 0x0002
REG = 0x3E28 , 0x252F
REG = 0x3E80 , 0x0009

//Initialize FSM sFOT for 12 lane operation
REG_BURST = 0x40F8, 0x501A, 0x0072, 0x500B, 0x0072, 0x501A, 0x0072, 0x500D, 0x0072, 0x5001, 0x0070, 0x5032, 0x00F0, 0x5021, 0x00f0, 0x5021, 0x0070, 0x5020, 0x0071


[Hidden: Enable6lanes]
REG = 0x3810, 0x02DC //line time
REG = 0x38C4, 0x0600

REG = 0x3A00, 0x000D
REG = 0x3A02, 0x0001

REG = 0x3E00, 0x0001
REG = 0x3E28, 0x253F
REG = 0x3E80, 0x000D

//Initialize FSM sFOT for 6 lane operation
REG_BURST = 0x40F8, 0x501F, 0x0072, 0x501F, 0x0072, 0x5013, 0x0072, 0x5007, 0x0072, 0x501A, 0x0072, 0x500D, 0x0072, 0x5001, 0x0070, 0x5032, 0x00f0, 0x5021, 0x00F0, 0x5021, 0x0070, 0x5020, 0x0071

[Hidden:Python: EnableCompanding]
lanes = reg.reg(0x3E80).value

#6 lanes
if lanes == 13:
    reg.reg(0x3502).value = 12363
    reg.reg(0x3E2E).value = 1
    reg.reg(0x3E28).value = 9279
    reg.reg(0x3810).value = 610
    reg.reg(0x3E00).value = 3

#12 lanes    
if lanes == 9:    
    reg.reg(0x3502).value = 12363
    reg.reg(0x3E2E).value = 1
    reg.reg(0x3E28).value = 9263
    reg.reg(0x3810).value = 305
    reg.reg(0x3E00).value = 3
    apbase.setstate('RX Mode', 1) #Remove when SP packetized for 12 lanes subsampling is fixed

#18 lanes    
if lanes == 5:
    reg.reg(0x3502).value = 12363
    reg.reg(0x3E2E).value = 1
    reg.reg(0x3E28).value = 9247
    reg.reg(0x3810).value = 230
    reg.reg(0x3E00).value = 8

#24 lanes    
if lanes == 1:
    reg.reg(0x3502).value = 12363
    reg.reg(0x3E2E).value = 1
    reg.reg(0x3E28).value = 9231
    reg.reg(0x3810).value = 230
    reg.reg(0x3E00).value = 9
    apbase.setstate('RX Mode', 1) #Remove when SP packetized for 24 lanes is fixed

[Triggered_Mode]
REG = 0x38CA, 0x0707
REG = 0x38CC, 0x0007

//FSM sFOT
//Reg Address       0x40F8
REG_BURST = 0x40F8, 0x5001, 0x0072, 0x501A, 0x0072, 0x500D, 0x0072, 0x5001, 0x0070, 0x5032, 0x00F0, 0x5021, 0x00F0, 0x5021, 0x0070, 0x5020, 0x0071, 0x5522, 0x807d, 0x502f, 0x807d, 0x502d, 0x807d

[Hidden: empty]

[Hidden: python: check_color]
if apbase.getstate("Monochrome") != 1:
    apbase.log('Color device selected')
    apbase.setstate("Auto Offset", 0)
    apbase.setstate("X Offset", 1)
    apbase.setstate("Y Offset", 0)
    reg.reg(0x3800).bitfield(0x02).value = 1
    apbase.setstate("Color Correction", 0)
    #apbase.load_preset("Enable_CCM")

[Enable_CCM]
STATE= Color Correction, 1
STATE= White Balance, 1
STATE= AWB Incandescent, 1.6637 -0.3802 -0.2835 -0.3523 1.0374 0.3149 -0.1224 -0.7913 1.9137
STATE= AWB Incandescent Gain, 0.6890 2.8520
STATE= AWB Incandescent Temp, 2500
STATE= AWB Middle, 1.7084 -0.4617 -0.2467 -0.3640 1.2551 0.1089 -0.0315 -0.4440 1.4756
STATE= AWB Middle Gain, 1.1740 2.3540
STATE= AWB Middle Temp, 3431
STATE= AWB Sun, 1.5626 -0.2556 -0.3070 -0.2841 1.4050 -0.1209 0.0067 -0.3339 1.3272
STATE= AWB Sun Gain, 1.2550 1.0860
STATE= AWB Sun Temp, 6500
STATE= AWB Weight Map Method, 2
STATE= AWB Weight Map, 0 17 29202 28928 0 369 10098 28928 0 16 273 8448 0 272 1 30480 1 10097 0 4352 4391 29473 257 4369 30583 30503 10023 30583 30583 30519 8449 4983
STATE= AWB Weight Map X Scale, 132
STATE= AWB Weight Map Y Scale, 158
STATE= AWB Weight Map X Shift, 31
STATE= AWB Weight Map Y Shift, 12
STATE= AWB Weight Map X Center, -6
STATE= AWB Weight Map Y Center, -30
STATE= AWB Weight Map Angle Sin, 55
STATE= AWB Weight Map Angle Cos, 33
STATE= AWB Weight Map Luma Low, 4
STATE= AWB Weight Map Luma High, 251
